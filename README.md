 # 背景 #
现代数据库存储引擎所面临的读写场景大致可以分为两类：读多写少和写多读少，读多写少的场景主要采用基于B+树的数据库，例如MySQL，而写多读少的场景则主要是采用本项目的主角：LSM-Tree，代表的产品是RocksDB

# 需求分析 #
对于写多读少的场景，影响系统整体效率的最关键因素就是写操作时延，传统的磁盘写方式是随机写，就是根据KV对信息找到数据存放在磁盘的位置然后进行数据更新

这种方式在每次写操作时都需要磁头进行寻道，当写请求数量变得无比庞大时，写请求的响应时延就很低

解决这个问题的方法很简单，就是采用追加写的方式，每一次写入数据都会在文件的末尾追加一个新的KV对，这就避免了磁头的寻道，提高了写操作的效率

但这样做也会带来一些坏处，主要有两点：数据冗余和读性能低

追加写会导致同一组KV对存储多个冗余记录，除了最后一个此前所有记录都是无用的，在极端情况下，只需一个KV对记录，进行无限次的写操作就会占满整个磁盘空间

另一个问题就是读性能降低，因为每一次查询都需要从后向前回溯，直到找到最新的KV数据记录，这样操作的最坏时间复杂度是O(N)，显然无法满足需求

#  方案设计 #

## 压缩合并 ##
压缩合并方案的提出是为了解决数据冗余的问题，他的思想很简单，就是将没有用的旧数据给删除掉，这个操作成为compact，但真正实施起来还需要解决一些细节问题

首先就是资源争用，compact操作和write操作是并发执行的，这就需要对数据加锁来管理资源争用，这样子就会大大降低系统效率。解决方法就是将文件分块，称为Table，每一个Table都有最大容量，例如4KB，当追加写的数据超过这个容量之后就会触发Table分裂，生成一个新Table。这样一来，compact操作就只用在旧的Table中执行，而write操作就在最新的Table中追加新数据就行了。通过这样解耦就可以降低资源争用的开销

## 数据有序存储 ##
数据有序存储是为了解决读性能低的问题，基于上一节讲到的分块，我们对每一个Table内的数据进行有序存储，这样在进行数据查找时就可以使用二分查找的方法来降低读时间复杂度
